        - module TimeFreqFFTs
        - 
        - using UnsafeArrays
        - using LinearAlgebra
        - using FFTW
        - 
        - using ..Lattices:   Lattice
        - 
        - struct TimeFreqFFT{T<:AbstractFloat}
        - 
        -     "Number of site in lattice."
        -     N::Int
        - 
        -     "Length of imaginary time axis."
        -     L::Int
        - 
        -     "Vector to represent unitary transformation to restore translational invariance in imaginary time direction."
        -     Θ::Vector{Complex{T}}
        - 
        -     "FFT plan."
        -     fftplan::FFTW.cFFTWPlan{Complex{T},-1,false,2}
        - 
        -     "Inverse FFT plan."
        -     ifftplan::AbstractFFTs.ScaledPlan{Complex{T},FFTW.cFFTWPlan{Complex{T},1,false,2},T}
        - 
        -     "Temporary storage vector."
        -     vtemp::Array{Complex{T},2}
        - 
        -     "Temporary storage vector."
        -     utemp::Vector{Complex{T}}
        - 
        -     function TimeFreqFFT(lattice::Lattice{T},L::Int) where {T<:AbstractFloat}
        - 
        0         N        = lattice.nsites
    30800         vtemp    = zeros(Complex{T},L,N)
    30800         utemp    = zeros(Complex{T},L*N)
     2032         Θ        = [exp(-π*im*(τ-1)/L) for τ = 1:L]
        0         fftplan  = plan_fft(vtemp, (1,), flags=FFTW.PATIENT)
       32         ifftplan = plan_ifft(vtemp, (1,), flags=FFTW.PATIENT)
        - 
       64         return new{T}(N,L,Θ,fftplan,ifftplan,vtemp,utemp)
        -     end
        - end
        - 
        - 
        - """
        - Apply the transformation ν=[F⋅Θ]⋅v from imaginary time τ to frequency ω space.
        - """
        - function τ_to_ω!(vout::AbstractVector{Complex{T1}},op::TimeFreqFFT{T1},vin::AbstractVector{T2}) where {T1<:AbstractFloat,T2<:Number}
        - 
        0     L  = op.L::Int
        0     N  = op.N::Int
        0     Θ  = op.Θ::Vector{Complex{T1}}
        0     vtemp = op.vtemp::Array{Complex{T1},2}
        0     @uviews vin vout begin
        -         # apply unitary transformation to restore translation invariance in the
        -         # imaginary time direciton.
        -         uin  = reshape(vin,L,N)
        -         @fastmath @inbounds for i in 1:N
        -             for τ in 1:L
        -                 vtemp[τ,i] = Θ[τ] * uin[τ,i]
        -             end
        -         end
        -         # apply (τ ⟶ ω) FFT
        -         uout = reshape(vout,L,N)
        -         mul!(uout,op.fftplan,vtemp)
        -     end
        0     return nothing
        - end
        - 
        - function τ_to_ω!(vout::AbstractVector{T1},op::TimeFreqFFT{T1},vin::AbstractVector{T2}) where {T1<:AbstractFloat,T2<:Complex}
        - 
        -     τ_to_ω!(op.utemp,op,vin)
        -     @. vout = real(op.utemp)
        -     return nothing
        - end
        - 
        - function τ_to_ω!(v::AbstractVector{Complex{T}},op::TimeFreqFFT{T}) where {T<:AbstractFloat}
        - 
        -     τ_to_ω!(v,op,v)
        -     return nothing
        - end
        - 
        - 
        - """
        - Apply the transformation v=[Θᵀ⋅Fᵀ]⋅ν from frequency ω to imaginary time τ space.
        - """
        - function ω_to_τ!(vout::AbstractVector{Complex{T}},op::TimeFreqFFT{T},vin::AbstractVector{Complex{T}}) where {T<:AbstractFloat}
        - 
        0     L     = op.L::Int
        0     N     = op.N::Int
        0     Θ     = op.Θ::Vector{Complex{T}}
        0     vtemp = op.vtemp::Array{Complex{T},2}
        0     @uviews vin vout begin
        -         # apply (ω ⟶ τ) FFT
        -         uin  = reshape(vin, L,N)
        -         mul!(vtemp,op.ifftplan,uin)
        -         # apply unitary transformation to restore anitperiodic boundary conditions
        -         # imaginary time direciton.
        -         uout = reshape(vout,L,N)
        -         @fastmath @inbounds for i in 1:N
        -             for τ in 1:L
        -                 uout[τ,i] = conj(Θ[τ]) * vtemp[τ,i]
        -             end
        -         end
        -     end
        0     return nothing
        - end
        - 
        - function ω_to_τ!(vout::AbstractVector{T2},op::TimeFreqFFT{T1},vin::AbstractVector{T1};thresh::T1=1e-12) where {T1<:AbstractFloat,T2<:Complex}
        - 
        -     copyto!(op.vtemp,vin)
        -     ω_to_τ!(vout,op,op.vtemp)
        -     return nothing
        - end
        - 
        - function ω_to_τ!(vout::AbstractVector{T1},op::TimeFreqFFT{T1},vin::AbstractVector{T2};thresh::T1=1e-12) where {T1<:AbstractFloat,T2<:Complex}
        - 
        0     ω_to_τ!(op.utemp,op,vin)
        0     @. vout = real(op.utemp)
        0     return nothing
        - end
        - 
        - function ω_to_τ!(v::AbstractVector{Complex{T}},op::TimeFreqFFT{T}) where {T<:AbstractFloat}
        - 
        -     copyto!(op.vtemp,v)
        -     ω_to_τ!(v,op,op.vtemp)
        -     return nothing
        - end
        - 
        - end
