        - module HolsteinModels
        - 
        - using Statistics
        - using Printf
        - 
        - using ..Geometries: Geometry
        - using ..Lattices: Lattice, translationally_equivalent_sets, sort_neighbor_table!, loc_to_site
        - using ..Checkerboard: checkerboard_order, checkerboard_groups
        - using ..RestartedGMRES: GMRES, solve!
        - using ..ConjugateGradients: ConjugateGradient
        - using ..Utilities: get_index
        - 
        - export HolsteinModel
        - export assign_μ!, assign_ω!, assign_λ!, assign_ω4!
        - export assign_tij!, assign_ωij!
        - export get_index, get_site, get_τ
        - export setup_checkerboard!, construct_expnΔτV!
        - export write_phonons, read_phonons
        - 
        - mutable struct HolsteinModel{ T1<:AbstractFloat , T2<:Union{Float32,Float64,Complex{Float32},Complex{Float64}} }
        - 
        -     ################################
        -     ## COMPLETE MODEL HAMILTONIAN ##
        -     ################################
        - 
        -     # H =  ∑ Pᵢ²/2 + ∑ (ωᵢ²/2) xᵢ² [Einstein Phonons]
        -     #   +  ∑ λᵢ xᵢ nᵢ              [El-Ph Coupling]
        -     #   +  ∑ ωᵢⱼ(xᵢ ± xⱼ)²         [Phonon Dispersion]
        -     #   -  ∑ μᵢ nᵢ                 [Chemical Potential]
        -     #   -  ∑ tᵢⱼ(c⁺ᵢcⱼ + h.c.)     [Electron Kinetic Energy]
        - 
        -     ####################################################################
        -     ## CHARACTERIZING TEMPERATURE AND SIZE OF D+1 DIMENSIONAL LATTICE ##
        -     ####################################################################
        - 
        -     "inverse temperature"
        -     β::T1
        - 
        -     "discretization in imaginary time direction"
        -     Δτ::T1
        - 
        -     "length of imaginary time axis"
        -     Lτ::Int
        - 
        -     "number of sites in physical lattice"
        -     nsites::Int
        - 
        -     "size of D+1 dimensional lattice"
        -     nindices::Int
        - 
        -     #######################################
        -     ## FOR REPRESENTING LATTICE GEOMETRY ##
        -     #######################################
        - 
        -     "represents lattice geometry"
        -     geom::Geometry{T1}
        - 
        -     "represents lattice"
        -     lattice::Lattice{T1}
        - 
        -     "stores sets of translationally equivalent pairs of sites in lattice."
        -     trans_equiv_sets::Array{Int,7}
        - 
        -     ############################
        -     ## HOLSTEIN PHONON FIELDS ##
        -     ############################
        - 
        -     "phonon fields stored in the order `[x₁(1),...,x₁(Lτ),...,xₙ(1),...,xₙ(Lτ)]`
        -     where `n` is the number of sites in the lattice and `Lτ` is the length of the imaginary time axis."
        -     x::Vector{T1}
        - 
        -     ##############################################################
        -     ## VECTORS REPRESENTING MATRICE NEEDED TO LANGEVIN DYNAMICS ##
        -     ##############################################################
        - 
        -     "a vector representing the diagonal matrix exp(-Δτ⋅V[x])"
        -     expnΔτV::Vector{T2}
        - 
        -     #####################################################
        -     ## SPECIFIES ON-SITE ENERGIES (CHEMICAL POTENTIAL) ##
        -     #####################################################
        - 
        -     "chemical potential for each site in lattice"
        -     μ::Vector{T1}
        - 
        -     #############################################################
        -     ## SPECIFIES ELECTRON KINETIC ENERGY (TIGHT BINDING MODEL) ##
        -     #############################################################
        - 
        -     "electron hopping energies in tight binding model"
        -     tij::Vector{T2}
        - 
        -     "cosh of electron hopping parameters in tij"
        -     coshtij::Vector{T2}
        - 
        -     "sinh of electron hopping parameters in tij"
        -     sinhtij::Vector{T2}
        - 
        -     "neighboring sites in tight binding model"
        -     neighbor_table_tij::Matrix{Int}
        - 
        -     ##############################
        -     ## SPECIFIES HOLSTEIN MODEL ##
        -     ##############################
        - 
        -     "frequency of each phonon"
        -     ω::Vector{T1}
        - 
        -     "local electron-phonon coupling"
        -     λ::Vector{T1}
        - 
        -     "coefficient for anharmonic term X^4"
        -     ω4::Vector{T1}
        - 
        -     ###################################
        -     ## SPECIFIES HOLSTEIN DISPERSION ##
        -     ###################################
        - 
        -     "extended holstein frequency of the form ωij(xᵢ±xⱼ)²"
        -     ωij::Vector{T2}
        - 
        -     "specifies which two sites i,j that are coupled in ωij(xᵢ±xⱼ)²"
        -     neighbor_table_ωij::Matrix{Int}
        - 
        -     "specifies the sign: ωij(xᵢ+xⱼ)² or ωij(xᵢ-xⱼ)²"
        -     sign_ωij::Vector{Int}
        - 
        -     #################################################
        -     ## VARIBALES FOR SOLVING M⋅x=g VIA ITERATIVELY ##
        -     #################################################
        - 
        -     "Tolerace when solve M⋅x=g iteratively."
        -     tol::T1
        - 
        -     "A vector of length `ninidces` to temporarily store data."
        -     ytemp::Vector{T2}
        - 
        -     "A vector for storing the temporary product Mᵀ⋅g needed for Conjugate Gradient method."
        -     Mᵀg::Vector{T2}
        - 
        -     "If true the default matrix multiplication uses just the M matrix.
        -     If false the default matrix multiplication use the symmetric matrix MᵀM instead."
        -     mul_by_M::Bool
        - 
        -     "If true multiply by Mᵀ instead of M."
        -     transposed::Bool
        - 
        -     "Stores state vectors for Conjugate Gradient algorithm so as to avoid
        -     extra memory allocations."
        -     cg::ConjugateGradient{T2,T1}
        - 
        -     "GMRES type that preallocates memory for algorithm."
        -     gmres::GMRES{T1,T2}
        - 
        -     #######################
        -     ## INNER CONSTRUCTOR ##
        -     #######################
        - 
        -     """
        -     Constructor for Holstein type.
        -     """
        -     function HolsteinModel(geom::Geometry{T}, lattice::Lattice{T}, β::T, Δτ::T;
        -                            is_complex::Bool=false, tol::T=1e-4, mul_by_M::Bool=false, restart::Int=-1) where {T<:AbstractFloat}
        - 
        -         # calculating length of imaginary time axis
        0         Lτ = round(Int,β/Δτ)
        - 
        -         # number of sites in lattice
        0         nsites = lattice.nsites
        - 
        -         # size of D+1 dimensional lattice
        0         nindices = nsites*Lτ
        - 
        -         # constructing translationally equivalent sets of sites
        0         trans_equiv_sets = translationally_equivalent_sets(lattice)
        - 
        -         # initialize ineraction matrix, which is diagonal so stored as vector
    15488         expnΔτV = zeros(T,nindices)
        - 
        -         # intializing phonon fields to zero
    15488         x = zeros(T,nindices)
        - 
        -         # initializing all on-site energies to zero
      208         μ = zeros(T,nsites)
        - 
        -         # initialize hopping parameters to empty vector
       80         tij = Vector{T}(undef,0)
        - 
        -         # initialize hopping parameters to empty vector
       80         coshtij = Vector{T}(undef,0)
        - 
        -         # initialize hopping parameters to empty vector
       80         sinhtij = Vector{T}(undef,0)
        - 
        -         # initializing empty matrix to contain tight binding model neighbor_table
       80         neighbor_table_tij = Matrix{Int}(undef,2,0)
        - 
        -         # intializing phonon frequencies to zero
      208         ω = zeros(T,nsites)
        - 
        -         # initialize electron-phonon coupling to zero
      208         λ = zeros(T,nsites)
        - 
        -         # initialize anharmonic X^4 term coefficient
      208         ω4 = zeros(T,nsites)
        - 
        -         # initizlize empty vector for inter-site phonon frequencies
       80         ωij = Vector{T}(undef,0)
        - 
        -         # intialize empty matrix for storing inter-site phonon frequency neighbor_table
       80         neighbor_table_ωij = Matrix{Int}(undef,2,0)
        - 
        -         # intialize empty vector for sign_ωij
       80         sign_ωij = Vector{Int}(undef,0)
        - 
        -         # temporary vectors
    15488         ytemp = zeros(T,nindices)
        - 
        -         # if true multiply by Mᵀ instead of M
        -         transposed = false
        - 
        -         # constructing holstein model
        0         if is_complex
        - 
        -             # temporary vectors
        0             Mᵀg = zeros(Complex{T},nindices)
        - 
        -             # conjugate gradient state variables
        0             cg = ConjugateGradient(Mᵀg,tol=tol)
        - 
        -             # GMRES type
        0             gmres = GMRES(Mᵀg,tol=tol,restart=restart)
        - 
        0             new{T,Complex{T}}(β, Δτ, Lτ, nsites, nindices, geom, lattice, trans_equiv_sets, x, expnΔτV,
        -                               μ, tij, coshtij, sinhtij, neighbor_table_tij,
        -                               ω, λ, ω4, ωij, neighbor_table_ωij, sign_ωij,
        -                               tol, ytemp, Mᵀg, mul_by_M, transposed, cg, gmres)
        -         else
        - 
        -             # temporary vectors
    15488             Mᵀg = zeros(T,nindices)
        - 
        -             # conjugate gradient state variables
        0             cg = ConjugateGradient(Mᵀg,tol=tol)
        - 
        -             # GMRES type
        0             gmres = GMRES(Mᵀg,tol=tol,restart=restart)
        - 
      224             new{T,T}(β, Δτ, Lτ, nsites, nindices, geom, lattice, trans_equiv_sets, x, expnΔτV,
        -                      μ, tij, coshtij, sinhtij, neighbor_table_tij,
        -                      ω, λ, ω4, ωij, neighbor_table_ωij, sign_ωij,
        -                      tol, ytemp, Mᵀg, mul_by_M, transposed, cg, gmres)
        -         end
        -     end
        - 
        - end
        - 
        - #####################
        - ## PRETTY PRINTING ##
        - #####################
        - 
        - function Base.show(io::IO, holstein::HolsteinModel)
        - 
        -     type1 = typeof(holstein.ω).parameters[1]
        -     type2 = typeof(holstein.tij).parameters[1]
        -     printstyled( "HolsteinModel{" , type1 , "," , type2 , "}\n" ; bold=true , color=:cyan )
        -     print('\n')
        -     println("β = ",holstein.β)
        -     println("Δτ = ",holstein.Δτ)
        -     println("Lτ = ",holstein.Lτ)
        -     println("nsites = ",holstein.nsites)
        -     println("nindices = ",holstein.nindices)
        -     print('\n')
        -     print(holstein.geom)
        -     print('\n')
        -     print('\n')
        -     print(holstein.lattice)
        -     print('\n')
        -     printstyled("Parameters\n";bold=true)
        -     print('\n')
        -     println("trans_equiv_sets: ", typeof(holstein.trans_equiv_sets),size(holstein.trans_equiv_sets))
        -     print('\n')
        -     _print_local_param(holstein.lattice.site_to_orbit,holstein.μ,"μ")
        -     _print_local_param(holstein.lattice.site_to_orbit,holstein.ω,"ω")
        -     _print_local_param(holstein.lattice.site_to_orbit,holstein.λ,"λ")
        -     if length(holstein.tij)>0
        -         print('\n')
        -         _print_nonlocal_param(holstein.tij,holstein.neighbor_table_tij,"tij")
        -     end
        -     if length(holstein.ωij)>0
        -         print('\n')
        -         _print_nonlocal_param(holstein.ωij,holstein.neighbor_table_ωij,"ωij")
        -     end
        - end
        - 
        - function _print_local_param(orbits::Vector,vals::Vector,param::String)
        - 
        -     for orbit in 1:maximum(orbits)
        -         avg = mean(vals[orbits.==orbit])
        -         sd = std(vals[orbits.==orbit])
        -         println(param, ", orbit = ", orbit, ", mean = ",avg,", std = ",sd)
        -     end
        -     return nothing
        - end
        - 
        - function _print_nonlocal_param(vals::Vector,neighbor_table::Matrix{Int},param::String)
        - 
        -     println(param,": ", typeof(vals),size(vals), ", mean = ", mean(vals), ", std = ", std(vals))
        -     println("neighbor_table_", param, ": ", typeof(neighbor_table), size(neighbor_table))
        -     # show(IOContext(stdout, :limit => true), "text/plain", neighbor_table)
        -     print('\n')
        -     return nothing
        - end
        - 
        - #############################################################################
        - ## DEFINING METHODS TO INCREMENTALLY SPECIFY THE HOLSTEIN MODEL PARAMETERS ##
        - #############################################################################
        - 
        - # GENERATE THE FOLLOWING FUNCTIONS: assign_μ!, assign_ω!, assign_λ!, assign_ω4!
        - for param in [ :μ , :ω , :λ, :ω4 ]
        - 
        -     # constructing symbol for function name
        -     op = Symbol(:assign_,param,:!)
        - 
        -     # defining functions
        -     @eval begin
        -         function $op(holstein::HolsteinModel{T},μ0::T,σ0::T,orbit::Int=0) where {T<:AbstractFloat}
        - 
        0             if orbit==0 # assigning parameter values for all sites
        0                 holstein.$param .= μ0 .+ σ0 .* randn(length(holstein.$param))
        -             else # assigning paramerter values for only sites of certain kind of orbital
        0                 for i in 1:length(holstein.$param)
        0                     if holstein.lattice.site_to_orbit[i]==orbit
        0                         holstein.$param[i] = μ0 + σ0 * randn()
        -                     end
        -                 end
        -             end
        - 
        0             return nothing
        -         end
        -     end
        - 
        - end
        - 
        - 
        - # GENERATE THE FOLLOWING FUNCTIONS: assign_tij!, assign_ωij!
        - for param in [ :tij , :ωij ]
        - 
        -     # defining symbol for function name
        -     op = Symbol(:assign_,param,:!)
        - 
        -     # symbol for name of neighbor table
        -     neighbor_table = Symbol(:neighbor_table_,param)
        - 
        -     # defining functions when parameter value is complex
        -     @eval begin
        -         function $op(holstein::HolsteinModel{T1,T2}, μ0::T2, σ0::T1, orbit1::Int, orbit2::Int, displacement::Vector{Int}) where {T1<:AbstractFloat,T2<:Complex}
        - 
        -             # phase of μ0
        -             phase = angle(μ0)
        - 
        -             # amplitude of μ0
        -             mag = abs(μ0)
        - 
        -             # getting total number of neighbors before new neighbors added
        -             nneighbors = length(holstein.$param)
        - 
        -             # getting parameters values ignoring complex phase
        -             $op(holstein,mag,σ0,orbit1,orbit2,displacement)
        - 
        -             # reapplying phase of complex number
        -             holstein.$param[nneighbors+1:end] .*= exp(im*phase)
        - 
        -             return nothing
        -         end
        -     end
        - 
        -     # defining functions when parameter value is real
        -     @eval begin
        -         function $op(holstein::HolsteinModel{T1,T2}, μ0::T1, σ0::T1, orbit1::Int, orbit2::Int, displacement::Vector{Int}) where {T1<:AbstractFloat,T2<:Number}
        - 
        -             # getting new neighbors
      672             newneighbors = holstein.trans_equiv_sets[:,:,displacement[1]+1,displacement[2]+1,displacement[3]+1,orbit2,orbit1]
        - 
        -             # getting number of new neighbors
        0             nnewneighbors = size(newneighbors,2)
        - 
        -             # adding new neighbors to neighbor table
     1024             holstein.$neighbor_table = hcat(holstein.$neighbor_table,newneighbors)
        - 
        -             # getting parameter value associated with each new neighbor
        0             for i in 1:nnewneighbors
      544                 push!( holstein.$param , μ0 + σ0 * randn() )
        -             end
        - 
        0             return nothing
        -         end
        -     end
        - 
        - end
        - 
        - 
        - # adding functionality to assign_ωij! function so that the array holsteinmodel.sign_ωij is also modified
        - function assign_ωij!(holstein::HolsteinModel, μ0::Number, σ0::Number, sgn::Int, orbit1::Int, orbit2::Int, displacement::Vector{Int})
        - 
        -     @assert abs(sgn)==1
        - 
        -     # updating neighbor table and parameter values
        -     assign_ωij!(holstein,μ0,σ0,orbit1,orbit2,displacement)
        - 
        -     # number of new neighbors constructed
        -     nnewneighbors = div(holstein.lattice.nsites,holstein.lattice.norbits)
        - 
        -     # modifying holsteinmodel.sign_ωij array
        -     append!( holstein.sign_ωij , fill(Int,sgn,nnewneighbors) )
        - 
        -     return nothing
        - end
        - 
        - #######################################################
        - ## MORE FUNCTIONS ASSOCIATED WITH HOLSTEINMODEL TYPE ##
        - #######################################################
        - 
        - """
        -     function setup_checkerboard!(holstein::HolsteinModel{T1,T2}) where {T1<:AbstractFloat,T2<:Number}
        - 
        - Function for sorting the hopping parameters in HolsteinModel and calculating the
        - cosh and sinh of the hopping parameters so that the checkerboard decomposition
        - is ready to go.
        - """
        - function setup_checkerboard!(holstein::HolsteinModel{T1,T2}) where {T1<:AbstractFloat,T2<:Number}
        - 
        0     if length(holstein.tij)>0
        - 
        -         # sort neighbor_table_tij
        0         perm = sort_neighbor_table!(holstein.neighbor_table_tij)
      352         holstein.tij .= holstein.tij[perm]
        - 
        -         # get checkerboard groups
      336         groups = checkerboard_groups(holstein.neighbor_table_tij)
        - 
        -         # get checkerboard permutation
      352         perm .= checkerboard_order(groups)
        - 
        -         # applying permutation
      688         holstein.neighbor_table_tij .= holstein.neighbor_table_tij[:,perm]
      352         holstein.tij .= holstein.tij[perm]
        - 
        -         # calculate cosh and sinh of hopping parameters
      336         holstein.coshtij = @. cosh(holstein.Δτ*holstein.tij)
      336         holstein.sinhtij = @. sinh(holstein.Δτ*holstein.tij)
        -     end
        - 
        0     return nothing
        - end
        - 
        - """
        -     function construct_expnΔτV!(holstein::HolsteinModel{T1,T2}) where {T1<:AbstractFloat,T2<:Number}
        - 
        - Constructs the exponentiated interaction matrix for the Holstein Model
        - exp(-Δτ⋅V[x]) based on the current phonon fields x. Note that the matrix
        - exp(-Δτ⋅V[x]) is stored as a vector as it is a diagonal matrix.
        - """
        - function construct_expnΔτV!(holstein::HolsteinModel{T1,T2}) where {T1<:AbstractFloat,T2<:Number}
        - 
        0     expnΔτV  = holstein.expnΔτV::Vector{T2}
        0     λ        = holstein.λ::Vector{T1}
        0     μ        = holstein.μ::Vector{T1}
        0     x        = holstein.x::Vector{T1}
        0     Δτ       = holstein.Δτ::T1
        0     Lτ       = holstein.Lτ::Int
        0     nsites   = holstein.nsites::Int
        - 
        -     # iterating over time slices
        0     @inbounds @fastmath for i in 1:nsites
        -         # iterating over sites in lattice
        0         for τ in 1:Lτ
        -             # getting index in vector
        0             index = get_index(τ,i,Lτ)
        -             # updating matrix element exp{-Δτ⋅Vᵢᵢ(τ)} = exp{-Δτ⋅(λᵢ⋅xᵢ(τ)-μᵢ)}
        0             expnΔτV[index] = exp( -Δτ * ( λ[i] * x[index] - μ[i] ) )
        -         end
        -     end
        - 
        0     return nothing
        - end
        - 
        - ##################################################
        - ## Functionality for Phonon Field Read/Write IO ##
        - ##################################################
        - 
        - """
        - Writes the current phonon field configuration for a HolsteinModel to file.
        - """
        - function write_phonons(holstein::HolsteinModel,filename::String)
        - 
        -     # get lattice associated with holstein model
        -     lattice = holstein.lattice
        - 
        -     # get phonon fields
        -     x = holstein.x
        - 
        -     # open file
        -     open(filename,"w") do file
        - 
        -         # write header to file
        -         write(file, "tau orbit L1 L2 L3 x\n")
        - 
        -         # iterate over unit cells
        -         for l3 in 0:lattice.L3-1
        -             for l2 in 0:lattice.L2-1
        -                 for l1 in 0:lattice.L1-1
        - 
        -                     # iterate over orbitals/sites in each unit cell
        -                     for orbit in 1:lattice.norbits
        - 
        -                         # get site in lattice
        -                         site = loc_to_site(lattice,orbit,l1,l2,l3)
        - 
        -                         # iterate of time slice
        -                         for τ in 1:holstein.Lτ
        - 
        -                             # get index
        -                             i = get_index(τ, site, holstein.Lτ)
        -                             
        -                             # get phonon field for site
        -                             xi = x[i]
        - 
        -                             # write to file
        -                             write(file, @sprintf("%d %d %d %d %d %.6f\n",τ-1,orbit,l1,l2,l3,xi))
        -                         end
        -                     end
        -                 end
        -             end
        -         end
        -     end
        - 
        -     return nothing
        - end
        - 
        - """
        - Read phonon config from file.
        - """
        - function read_phonons(holstein::HolsteinModel{T1,T2},filename::String) where {T1<:AbstractFloat,T2<:Number}
        - 
        -     # open file
       16     open(filename,"r") do file
        - 
        -         # read in header
     1424         header = readline(file)
        - 
        -         # iterate over lines in file
       96         for line in eachline(file)
        - 
        -             # split line at white space
   768000             atoms = split(line," ")
        - 
        -             # extract info about location
        0             τ     = parse(Int,atoms[1]) + 1
        0             orbit = parse(Int,atoms[2])
        0             l1    = parse(Int,atoms[3])
        0             l2    = parse(Int,atoms[4])
        0             l3    = parse(Int,atoms[5])
        - 
        -             # get phonon field value
        0             xi = parse(T1,atoms[6])
        - 
        -             # map location on site
        0             site = loc_to_site(holstein.lattice, orbit, l1, l2, l3)
        - 
        -             # map site and τ onto index
        0             i = get_index(τ, site, holstein.Lτ)
        - 
        -             # assign phonon value
   122816             holstein.x[i] = xi
        -         end
        - 
        -     end
        - 
        -     # construct exponentiated interaction matrix
        0     construct_expnΔτV!(holstein)
        - 
        0     return nothing
        - end
        - 
        - ##############################################
        - ## Include Functionality to Handle M Matrix ##
        - ##############################################
        - 
        - include("HolsteinModelMatrix.jl")
        - 
        - end
        - 
