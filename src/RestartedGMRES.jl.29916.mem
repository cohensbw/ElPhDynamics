        - module RestartedGMRES
        - 
        - using LinearAlgebra
        - using UnsafeArrays
        - 
        - export GMRES, solve!
        - 
        - mutable struct GMRES{T1<:AbstractFloat,T2<:Number}
        -     
        -     ndim::Int
        -     maxiter::Int
        -     restart::Int
        -     tol::T1
        -     H::Matrix{T2}
        -     V::Matrix{T2}
        -     r::Vector{T2}
        -     w::Vector{T2}
        -     s::Vector{T2}
        -     y::Vector{T2}
        -     sn::Vector{T2}
        -     cs::Vector{T2}
        -     
        -     function GMRES(x::AbstractVector{T2}; maxiter::Int=-1,restart::Int=-1,tol::T1=1e-4) where {T1<:AbstractFloat,T2<:Number}
        -         
    10944         ndim = length(x)
        0         if maxiter<0
        -             maxiter = ndim
        -         end
        0         if restart<0
        0             restart = min(20,ndim)
        -         end
    11136         H  = zeros(T2,restart+1,restart)
   798880         V  = zeros(T2,ndim,restart+1)
    30976         r  = zeros(T2,ndim)
    30976         w  = zeros(T2,ndim)
      592         s  = zeros(T2,restart+1)
      592         y  = zeros(T2,restart+1)
      592         sn = zeros(T2,restart+1)
      592         cs = zeros(T2,restart+1)
      224         return new{T1,T2}(ndim,maxiter,restart,tol,H,V,r,w,s,y,sn,cs)
        -     end
        - end
        - 
        - 
        - function solve!(x::AbstractVector{T2},A,b::AbstractVector{T2},gmres::GMRES{T1,T2},M=I)::Tuple{Int,Int,T1} where {T1<:AbstractFloat,T2<:Number}
        -     
     4528     H  = gmres.H
        0     V  = gmres.V
        0     r  = gmres.r
        0     w  = gmres.w
        0     s  = gmres.s
        0     y  = gmres.y
        0     sn = gmres.sn
        0     cs = gmres.cs
        -     
        -     # calculating norm of b
        0     copyto!(r,b)
        0     ldiv!(M,r)
        0     normb = norm(r)
        0     if normb==0.0
        -         normb = 1.0
        -     end
        -     
        -     # calculating residual vector r and getting its norm
        0     mul!(r,A,x)  # r = A⋅x
        0     @. r = b - r # r = b - A⋅x
        0     ldiv!(M,r)   # r = M \ (b - A⋅x)
        0     β = norm(r)
        -     
        -     # iteration counter
        -     iter = 0
        -     
        -     # initialize error
        0     Δ = β/normb
        0     if Δ<gmres.tol
        0         return 3, iter, Δ
        -     end
        -     
        0     @uviews V begin
        -         @fastmath @inbounds while iter < gmres.maxiter        
        -             @. V[:,1] = r/β
        -             fill!(s,0.0)
        -             s[1]  = β
        -             for i in 1:gmres.restart
        -                 iter += 1
        -                 vi    = @view V[:,i]
        -                 mul!(w,A,vi)
        -                 ldiv!(M,w)
        -                 for k in 1:i
        -                     vk     = @view V[:,k]
        -                     H[k,i] = dot(vk,w)
        -                     @. w  -= H[k,i] * vk
        -                 end
        -                 H[i+1,i]    = norm(w)
        -                 @. V[:,i+1] = w / H[i+1,i]
        -                 for k in 1:i-1
        -                     H[k,i], H[k+1,i] = apply_plane_rotation(H[k,i], H[k+1,i], cs[k], sn[k])
        -                 end
        -                 cs[i], sn[i]     = generate_plane_rotation(H[i,i], H[i+1,i])
        -                 H[i,i], H[i+1,i] = apply_plane_rotation(H[i,i], H[i+1,i], cs[i], sn[i])
        -                 s[i], s[i+1]     = apply_plane_rotation(s[i], s[i+1], cs[i], sn[i])
        -                 Δ                = abs(s[i+1])/normb
        -                 if Δ < gmres.tol
        -                     update!(x,i,H,s,y,V)
        -                     return 2, iter, Δ
        -                 end
        -                 if iter==gmres.maxiter
        -                     break
        -                 end
        -             end
        -             update!(x,gmres.restart,H,s,y,V)
        -             mul!(r,A,x)  # r = A⋅x
        -             @. r = b - r # r = b - A⋅x
        -             ldiv!(M,r)   # r = M \ (b - A⋅x)
        -             β    = norm(r)
        -             Δ    = β/normb
        -             if Δ<gmres.tol
        -                 return 1, iter, Δ
        -             end
        -         end
        -     end
        0     return 0, iter, Δ
        - end
        - 
        - 
        - #######################
        - ## PRIVATE FUNCTIONS ##
        - #######################
        - 
        - function update!(x::AbstractVector,k::Int,H::Matrix,s::AbstractVector,y::AbstractVector,V::AbstractMatrix)
        -     
        0     copyto!(y,s)
        -     
        0     @fastmath @inbounds for i in k:-1:1
        0         y[i] /= H[i,i]
        0         for j in i-1:-1:1
        0             y[j] -= H[j,i] * y[i]
        -         end
        -     end
        - 
        0     @fastmath @inbounds for j in 1:k
        0         for i in 1:length(x)
        0             x[i] += y[j] * V[i,j]
        -         end
        -     end
        - 
        0     return nothing
        - end
        - 
        - function apply_plane_rotation(dx::T,dy::T,cs::T,sn::T)::Tuple{T,T} where {T<:Number}
        -     
        -     dxp =  cs * dx + conj(sn) * dy
        -     dyp = -sn * dx +      cs  * dy
        -     return dxp, dyp
        - end
        - 
        - function generate_plane_rotation(dx::T,dy::T)::Tuple{T,T} where {T<:Real}
        -     
        -     dz = dx + im*dy
        -     θ  = angle(dz)
        -     return cos(θ), sin(θ)
        - end
        - 
        - function generate_plane_rotation(dx::T,dy::T)::Tuple{T,T} where {T<:Complex}
        -     
        -     c = 0.0
        -     s = 1.0
        -     if dx != 0.0
        -         c = abs(dx)/sqrt(abs2(dx)+abs2(dy))
        -         s = (dy/dx)*c
        -     end
        -     return c, s
        - end
        - 
        - end
