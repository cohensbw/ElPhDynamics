        - module PerturbativePreconditioners
        - 
        - using  UnsafeArrays
        - using  LinearAlgebra
        - import LinearAlgebra: ldiv!, mul!, transpose
        - 
        - using ..HolsteinModels: HolsteinModel
        - using ..Checkerboard: checkerboard_mul!, checkerboard_inverse_mul!
        - using ..Checkerboard: checkerboard_transpose_mul!, checkerboard_inverse_transpose_mul!
        - using ..TimeFreqFFTs: TimeFreqFFT, τ_to_ω!, ω_to_τ!
        - using ..TightBindingFFTs: TightBindingFFT, add_bond!, calc_basis!, r_to_k!, k_to_r!
        - using ..Utilities: get_index
        - 
        - export LeftPerturbativePreconditioner, setup!
        - 
        - abstract type PerturbativePreconditioner end
        - 
        - mutable struct LeftPerturbativePreconditioner{T1<:AbstractFloat,T2<:Number} <: PerturbativePreconditioner
        - 
        -     "current freuqncy mode ω to consider"
        -     ω::Int
        - 
        -     "holstein model."
        -     holstein::HolsteinModel{T1,T2}
        - 
        -     "TimeFreqFFT object for mapping between τ ⟷ ω"
        -     timefreqfft::TimeFreqFFT{T1}
        - 
        -     "TightBindingFFT"
        -     tightbindingfft::TightBindingFFT{T1}
        - 
        -     "Specifies whether to do a small V or small K expansion.
        -     If true  then do small V expansion away from non-interacting limit.
        -     If false then do small K expansion away from single-site limit."
        -     limit::Vector{Bool}
        - 
        -     "Order of perturbative expansion for each frequency mode ω"
        -     order::Vector{Int}
        - 
        -     "Regularization term applied to each frequency mode."
        -     η::Vector{T1}
        - 
        -     "z(ω) = exp{i⋅Δτ⋅2π/β⋅(ω+1/2)}"
        -     z::Vector{Complex{T1}}
        - 
        -     "exp{-Δτ⋅V̄} = (1/L)∑exp{-Δτ⋅V(τ)}"
        -     expnΔτVbar::Vector{Complex{T1}}
        - 
        -     "Green's functions evaluated in a specified limit.
        -     Gₛ(ω) = [-z⋅(I - zᵀ(ω)⋅Aₛ⁻¹ - i⋅Δτ⋅η(ω))]⁻¹ for a small K expansion away from single-site limit.
        -     G₀(ω) = [I - z(ω)⋅B₀ + i⋅Δτ⋅η(ω)]⁻¹ where B₀=exp{-Δτ(K-c₀)} for a small V expansion away from non-interacting limit.
        -     The elements of G₀ are computed assuming you are in the momentum space where K is diagonal."
        -     G::Matrix{Complex{T1}}
        - 
        -     "Define exp{-Δτ⋅cₛ} such that Aₛ = exp{-Δτ⋅(V̄+cₛ)}"
        -     expnΔτcs::T1
        - 
        -     "Define exp{-Δτ⋅c₀} such that A₀ = exp{-Δτ⋅(V̄+c₀)}"
        -     expnΔτc0::T1
        - 
        -     "Temporary vector length NL."
        -     v1::AbstractVector{Complex{T1}}
        - 
        -     "Temporary vector length NL."
        -     v2::AbstractVector{Complex{T1}}
        - 
        -     "Temporary vector length N."
        -     v3::AbstractVector{Complex{T1}}
        - 
        -     "Temporary vector length N."
        -     v4::AbstractVector{Complex{T1}}
        - 
        -     function LeftPerturbativePreconditioner(holstein::HolsteinModel{T1,T2}, tightbindingfft::TightBindingFFT{T1}) where {T1<:AbstractFloat,T2<:Number}
        - 
     2304         N   = holstein.nsites
        0         L   = holstein.Lτ
        0         NL  = N*L
        0         Lo2 = cld(L,2)
        - 
        0         timefreqfft = TimeFreqFFT(holstein.lattice,L)
        -         ω           = 1
      144         limit       = zeros(Bool,Lo2)
      576         order       = zeros(Int,Lo2)
      576         η           = ones(T1,Lo2)
     2032         z           = [exp(2*π*im*((ω-1)+1/2)/L) for ω in 1:L] # z(ω) = exp{i⋅Δτ⋅2π/β⋅(ω+1/2)}
      336         expnΔτVbar  = zeros(Complex{T1},N)
    15488         G           = zeros(Complex{T1},N,Lo2)
        -         expnΔτcs    = 1.0
        -         expnΔτc0    = 0.0
    30800         v1          = zeros(Complex{T1},NL)
    30800         v2          = zeros(Complex{T1},NL)
      336         v3          = zeros(Complex{T1},N)
      336         v4          = zeros(Complex{T1},N)
        - 
      144         return new{T1,T2}(ω,holstein,timefreqfft,tightbindingfft,limit,order,η,z,expnΔτVbar,G,expnΔτcs,expnΔτc0,v1,v2,v3,v4)
        -     end
        - end
        - 
        - 
        - function setup!(op::LeftPerturbativePreconditioner{T1,T2}) where {T1<:AbstractFloat,T2<:Number}
        - 
     6624     N  = op.holstein.nsites::Int
        0     L  = op.holstein.Lτ::Int
        0     Δτ = op.holstein.Δτ::T1
        - 
        -     # calulcate diagonal matrix exp{-Δτ⋅V̄} = (1/L)∑exp{-Δτ⋅V(τ)}
        0     expnΔτV = op.holstein.expnΔτV::Vector{T2}
        0     @fastmath @inbounds for i in 1:N
        0         op.expnΔτVbar[i] = 0.0
        0         for τ in 1:L
        0             op.expnΔτVbar[i] += expnΔτV[get_index(τ,i,L)]
        -         end
        0         op.expnΔτVbar[i] /= L
        -     end
        - 
        -     # set exp{-Δτ⋅c₀} value
        0     expnVbar0   = sum(op.expnΔτVbar)/N # exp{-Δτ⋅V̄₀} = avg[exp{-Δτ⋅V̄}] 
        0     op.expnΔτc0 = 1.0/expnVbar0        # exp{-Δτ⋅c₀} where c₀ = -V̄₀
        - 
        -     # set exp{-Δτ⋅cₛ} value
        0     op.expnΔτcs = 1.0 # exp{-Δτ⋅cₛ}
        - 
        -     # λ are the eigenvalues of the K matrix.
        0     λ = op.tightbindingfft.λk::Array{T1,4}
        - 
        -     # iterate over frequency
        0     @fastmath @inbounds for ω in 1:cld(L,2)
        -         # i⋅Δτ⋅η(ω)
        0         iΔτη = im*Δτ*op.η[ω]
        -         # z(ω) = exp{i⋅Δτ⋅2π/β⋅(ω+1/2)}
        0         z = op.z[ω]
        -         # if doing small V expansion away from non-interacting limit
        0         if op.limit[ω]
        -             # iterate over momentum space k states
        0             for k in 1:N
        -                 # G₀(ω) = [I - z(ω)⋅B₀ + i⋅Δτ⋅η(ω)]⁻¹ where B₀=exp{-Δτ(K-c₀)}=exp{-Δτ⋅K}⋅exp{+Δτ⋅c₀}
        0                 B0        = exp(-Δτ*λ[k])/op.expnΔτc0
        0                 op.G[k,ω] = 1.0/(1.0 - z*B0 + iΔτη)
        -             end
        -         # if doing small K expansion away from single-site limit
        -         else
        -             # iterate over real space sites in lattice
        0             for i in 1:N
        -                 # Gₛ(ω) = [-z⋅(I - zᵀ(ω)⋅Aₛ⁻¹ - i⋅Δτ⋅η(ω))]⁻¹ where Aₛ=exp{-Δτ⋅(V̄+cₛ)}=exp{-Δτ⋅V̄}⋅exp{-Δτ⋅cₛ}
        0                 As        = op.expnΔτVbar[i]*op.expnΔτcs
        0                 op.G[i,ω] = 1.0/(-z*( 1.0 - conj(z)/As - iΔτη))
        -             end
        -         end
        -     end
        - 
        0     return nothing
        - end
        - 
        - function setup!(op)
        - 
        -     return nothing
        - end
        - 
        - 
        - function ldiv!(vout::AbstractVector{T},op::PerturbativePreconditioner,vin::AbstractVector{T}) where {T<:AbstractFloat}
        - 
        - 
        0     N  = op.holstein.nsites::Int
        0     L  = op.holstein.Lτ::Int
        0     v1 = op.v1
        0     v2 = op.v2
        - 
        -     # 1. apply phase factor to go from (anit-periodic)⟶(periodic) in τ
        -     # 2. FFT from τ ⟶ ω
        0     τ_to_ω!(v2,op.timefreqfft,vin)
        - 
   651904     @uviews v1 v2 begin
        - 
        -         a1  = reshape(v1,(L,N))
        -         a1T = reshape(v1,(N,L))
        -         a2  = reshape(v2,(L,N))
        -         a2T = reshape(v2,(N,L))
        - 
        -         transpose!(a1T,a2)
        -         fill!(v2,0.0)
        - 
        -         # iterating over half the range of frequencies
        -         for ω in 1:cld(L,2)
        - 
        -             # input vector
        -             u1 = @view a1T[:,ω]
        - 
        -             # output vector
        -             u2 = @view a2T[:,ω]
        - 
        -             # set frequency
        -             op.ω = ω
        - 
        -             if op.limit[ω]==true
        -                 # apply small V expansion away from non-interacting limit
        -                 mul_invM0!(u2,op,u1)
        -             else
        -                 # apply small K expansion away from single-site limit
        -                 mul_invMs!(u2,op,u1)
        -             end
        - 
        -             # accounting for symmetry
        -             u2_sym = @view a2T[:,L-ω+1]
        -             @. u2_sym = conj(u2)
        -         end
        - 
        -         transpose!(a1,a2T)
        -     end
        - 
        -     # 1. iFFT from ω ⟶ τ
        -     # 2. apply inverse phase factor to go from (periodic)⟶(anti-periodic) in τ
        0     ω_to_τ!(vout,op.timefreqfft,v1)
        - 
        0     return nothing
        - end
        - 
        - function ldiv!(op::PerturbativePreconditioner,v::AbstractVector)
        - 
        -     ldiv!(v,op,v)
        -     return nothing
        - end
        - 
        - 
        - """
        - Calculate v′=[1+G₀Γ₀+(G₀Γ₀)²+...]⋅G₀⋅A₀⁻¹⋅v product arrived at perturbing away from the non-interacting limit.
        - """
        - function mul_invM0!(vp::AbstractVector{Complex{T1}},op::LeftPerturbativePreconditioner{T1,T2},v::AbstractVector{Complex{T1}}) where {T1<:AbstractFloat,T2<:Number}
        - 
        -     Δτ   = op.holstein.Δτ::T1
        -     η    = op.η[op.ω]
        -     iΔτη = im*Δτ*η
        -     G    = op.G::Matrix{Complex{T1}}
        -     v0   = op.v3::Vector{Complex{T1}}
        -     vk   = op.v4::Vector{Complex{T1}}
        - 
        -     @uviews G begin
        - 
        -         # v′= A₀⁻¹⋅v where A₀ = exp{-Δτ⋅(V̄+c₀)} = exp{-Δτ⋅V̄}⋅exp{-Δτ⋅c₀}
        -         @. vp = v/op.expnΔτVbar/op.expnΔτc0
        - 
        -         # G₀(ω) = [I - z(ω)⋅B₀ + i⋅Δτ⋅η(ω)]⁻¹ where B₀=exp{-Δτ(K-c₀)}
        -         G0 = @view G[:,op.ω]
        - 
        -         # v′= G₀⋅A₀⁻¹⋅v 
        -         r_to_k!(vk,op.tightbindingfft,vp)
        -         @. vk = G0 * vk
        -         k_to_r!(vp,op.tightbindingfft,vk)
        - 
        -         # v′=[1 + G₀Γ₀ + (G₀Γ₀)² + ...]⋅G₀⋅A₀⁻¹⋅v where Γ₀ = I - A₀⁻¹ + Δτ⋅(iη)
        -         # Apply recursive algorithm to execute the multiplication by the expansion
        -         copyto!(v0,vp)
        -         @fastmath @inbounds for n in 1:op.order[op.ω]
        -             # vₙ = Γ₀⋅vₙ₋₁
        -             @. vp = vp - vp/op.expnΔτVbar/op.expnΔτc0 + iΔτη*vp
        -             # vₙ = G₀⋅Γ₀⋅vₙ₋₁
        -             r_to_k!(vk,op.tightbindingfft,vp)
        -             @. vk = G0 * vk
        -             k_to_r!(vp,op.tightbindingfft,vk)
        -             # vₙ = v₀ + G₀⋅Γ₀⋅vₙ₋₁
        -             @. vp = v0 + vp
        -         end
        -     end
        - 
        -     return nothing
        - end
        - 
        - 
        - """
        - Calculate v′=[1+GₛΓₛ+(GₛΓₛ)²+...]⋅Gₛ⋅Aₛ⁻¹⋅v product arrived at given by perturbing away from the single-site limit.
        - """
        - function mul_invMs!(vp::AbstractVector{Complex{T1}},op::LeftPerturbativePreconditioner{T1,T2},v::AbstractVector{Complex{T1}}) where {T1<:AbstractFloat,T2<:Number}
        - 
        0     Δτ   = op.holstein.Δτ::T1
        0     η    = op.η[op.ω]
        0     iΔτη = im*Δτ*η
        0     z    = op.z[op.ω]
        0     G    = op.G::Matrix{Complex{T1}}
        0     v0   = op.v3::Vector{Complex{T1}}
        0     vnp  = op.v4::Vector{Complex{T1}}
        - 
        0     neighbor_table_tij = op.holstein.neighbor_table_tij::Matrix{Int}
        0     coshtij = op.holstein.coshtij::Vector{T2}
        0     sinhtij = op.holstein.sinhtij::Vector{T2}
        - 
        0     @uviews G begin
        -         
        -         # Gₛ(ω) = [-z⋅(I - zᵀ(ω)⋅Aₛ⁻¹ - i⋅Δτ⋅η(ω))]⁻¹
        -         Gs = @view G[:,op.ω]
        - 
        -         # v′= Aₛ⁻¹⋅v where Aₛ = exp{-Δτ⋅(V̄+cₛ)} = exp{-Δτ⋅V̄}⋅exp{-Δτ⋅cₛ}
        -         @. vp = v/op.expnΔτVbar/op.expnΔτc0
        - 
        -         # v′= Gₛ⋅Aₛ⁻¹⋅v 
        -         @. vp = Gs * vp
        - 
        -         # v′=[1 + GₛΓₛ + (GₛΓₛ)² + ...]⋅Gₛ⋅Aₛ⁻¹⋅v where Γₛ = -z⋅[I-Bₛ-Δτ(iη)] where Bₛ=exp{-Δτ·(K-cₛ)}.
        -         # Apply recursive algorithm to execute the multiplication by the expansion
        -         copyto!(v0,vp)
        -         @fastmath @inbounds for n in 1:op.order[op.ω]
        -             # vₙ = Γₛ⋅vₙ₋₁
        -             @. vnp = vp / op.expnΔτcs # vₙ′ = exp{+Δτ⋅cₛ}⋅vₙ₋₁
        -             checkerboard_mul!(vnp,neighbor_table_tij,coshtij,sinhtij) # vₙ′= Bₛ⋅vₙ₋₁= exp{-Δτ·(K-cₛ)}⋅vₙ₋₁
        -             @. vp = vp - iΔτη*vp - vnp
        -             @. vp *= -z
        -             # vₙ = Gₛ⋅Γₛ⋅vₙ₋₁
        -             @. vp *= Gs
        -             # vₙ = v₀ + Gₛ⋅Γₛ⋅vₙ₋₁
        -             @. vp += v0
        -         end
        -     end
        - 
        0     return nothing
        - end
        - 
        - 
        - end
